/*
 * Check if a Given Binary tree is a Binary search tree
 * Use Addnode functions to properly build a BST.
* Use newnode calls to test the negative scenarios.
 */

#include <stdio.h>
#include "malloc.h"
typedef struct btree {
    int data;
    struct btree *left;
    struct btree *right;
}btree;

int min(int x, int y){
    return (x < y)?x:y;
}

btree *
newnode(int data)
{
    btree *tmp = NULL;
    
    tmp = (btree *)malloc(sizeof(btree));
    tmp->data = data;
    tmp->left = NULL;
    tmp->right = NULL;
    return tmp;
}

btree *
addnode(int data, btree *root)
{
    btree *tmp = NULL;
    
    if(root == NULL)
        return newnode(data);
        
    if(data < root->data){
        root->left = addnode(data, root->left);
    }
    else if(data > root->data){
        root->right = addnode(data, root->right);
    } else {
        printf("\nError:Duplicate entry");
    }
}

void
inorder(btree *root)
{
    if(root == NULL)
        return;
    
    inorder(root->left);
    printf("%d  ",root->data);
    inorder(root->right);
    return;
}

int is_btree(btree *root, int low, int hi, int sub_tree)
{
    int lt, rt;
    lt = rt = 0;
    
    if(root == NULL){
        return 0;
    }
    
    if(sub_tree == 0){
        if(root->data > hi){
            return -1;
        }else {
            lt = is_btree(root->left, low, hi, 0);
            rt = is_btree(root->right, low, hi, 1);
        }
        
    } else {
        if(root->data < low){
            return -1;
        } else {
            lt = is_btree(root->left, low, hi, 0);
            rt = is_btree(root->right, low, hi, 1);
        }
    }
    if((lt == rt) && (lt == 0))
        return 0;
    else
        return min(lt,rt);
}

int
check_is_btree(btree *root)
{
    int left_res=0, right_res =0;
    left_res = is_btree(root->left, 0, root->data, 0);
    right_res = is_btree(root->right, root->data, -1, 1);
    if(!left_res && !right_res){
        return 0;
    } else 
        return min(left_res, right_res);
}

int main()
{
    int val = 0;
    btree *root = NULL;
    /*root = addnode(10,root);
    root = addnode(12,root);
    root = addnode(8,root);
    root = addnode(15,root);
    root = addnode(5,root);*/
    root = newnode(4);
    root->left = newnode(1);
    root->right = newnode(5);
    root->left->left = newnode(0);
    root->left->right = newnode(2);
    root->right->left = newnode(3);
    root->right->right = newnode(6);
    inorder(root);
    val = check_is_btree(root);
    printf("\nThe given tree is %s ",(val==0)?"Binary tree":"Not a Binary tree");
    return 0;
}
